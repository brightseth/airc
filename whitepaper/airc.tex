\documentclass[11pt,a4paper]{article}

% ============================================================================
% AIRC Whitepaper v0.1.1
% Pilot-Ready for Controlled Deployments
% ============================================================================

% --- Packages ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[margin=1.25in]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{abstract}
\usepackage{amsmath}
\usepackage{microtype}
\usepackage{float}

% --- Colors ---
\definecolor{linkblue}{RGB}{0,102,204}
\definecolor{codegray}{RGB}{245,245,245}
\definecolor{codetext}{RGB}{40,40,40}

% --- Hyperref Setup ---
\hypersetup{
    colorlinks=true,
    linkcolor=linkblue,
    citecolor=linkblue,
    urlcolor=linkblue,
    pdftitle={AIRC: Agent Identity and Relay Communication},
    pdfauthor={Seth Goldstein},
}

% --- Code Listings ---
\lstset{
    backgroundcolor=\color{codegray},
    basicstyle=\ttfamily\small\color{codetext},
    breaklines=true,
    frame=single,
    framerule=0pt,
    xleftmargin=1em,
    xrightmargin=1em,
    aboveskip=1em,
    belowskip=1em,
}

% --- Section Formatting ---
\titleformat{\section}{\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries}{\thesubsubsection}{1em}{}

% --- Header/Footer ---
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\small AIRC v0.1.1}
\fancyhead[R]{\small January 2026}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

% --- Abstract Formatting ---
\renewcommand{\abstractnamefont}{\normalfont\bfseries}
\renewcommand{\abstracttextfont}{\normalfont\small}

% ============================================================================
% DOCUMENT
% ============================================================================

\begin{document}

% --- Title Block ---
\begin{center}
    {\LARGE\bfseries AIRC: Agent Identity \& Relay Communication}\\[0.5em]
    {\large A Minimal Protocol for AI Agent Coordination}\\[1.5em]

    {\normalsize
    \textbf{Seth Goldstein}\\[0.3em]
    \texttt{@seth} · \url{sethgoldstein.com} · \texttt{sethgoldstein@gmail.com}\\[1em]
    \textit{with}\\[0.3em]
    Claude Opus 4.5 (Anthropic), OpenAI Codex (GPT-5.2), Google Gemini\\[1.5em]

    Version 0.1.1 — January 2026\\
    \textit{Status: Pilot-ready for controlled deployments (private registries / trusted operators)}
    }
\end{center}

\vspace{1em}

% --- Abstract ---
\begin{abstract}
\noindent
AI agents can execute tools and delegate tasks, but they lack a shared social layer: presence, verifiable identity, and structured peer-to-peer context exchange. We present AIRC (Agent Identity \& Relay Communication), a minimal JSON-over-HTTP protocol that enables agents to discover one another, exchange cryptographically signed messages, and negotiate consent.

AIRC v0.1.1 specifies: identity registration with proof-of-possession, Ed25519 key lifecycle management (rotation, revocation), RFC 8785 canonical JSON, registry-signed consent handshakes, presence with privacy tiers, message ordering and pagination, enterprise authentication profiles, and governance structures.

AIRC is intentionally narrow—1:1 communication, typed payloads, and cryptographic attribution—without UI coupling or delivery guarantees. It aims to provide for agent coordination what IRC provided for early internet chat: simple primitives that unlock emergent behavior across heterogeneous runtimes.

\vspace{0.5em}
\noindent\textbf{Keywords:} AI agents, protocol design, identity, presence, cryptographic signing, inter-agent communication, Ed25519
\end{abstract}

\vspace{2em}

% --- Epigraph ---
\begin{center}
\textit{``This specification was written collaboratively by Claude, Codex, and Gemini.\\
The fact that they couldn't easily share context during that process is why this spec exists.''}
\end{center}

\vspace{2em}

% ============================================================================
% TABLE OF CONTENTS
% ============================================================================

\tableofcontents
\newpage

% ============================================================================
% SECTIONS
% ============================================================================

\section{Introduction}
\label{sec:introduction}

\begin{quote}
\textit{``The terminal was never a developer tool — it was a private room. AI just made it social again.''}
\end{quote}

\subsection{The Problem}

AI agents live in silos. They can call tools (MCP) or delegate tasks (A2A), but they cannot reliably answer:

\begin{itemize}[noitemsep]
    \item \textit{Who else is here?}
    \item \textit{Who can I trust?}
    \item \textit{Can I send context to another agent safely?}
\end{itemize}

Each platform builds its own presence model, identity scheme, and messaging format. Without a shared layer, agent-to-agent coordination remains bespoke and brittle.

\subsection{The Genealogy of Coordination}

AIRC is the next step in a thirty-year evolution:

\begin{description}[noitemsep]
    \item[IRC (1988)] The spiritual ancestor. Channels, stateless clients, the ``room'' metaphor.
    \item[AIM/ICQ (1996)] The invention of Presence. The Buddy List proved that knowing \textit{who} is online is often more valuable than the message itself.
    \item[XMPP (1999)] The dream of federation. Proved standards work, but failed because incentives favored closed silos.
    \item[Slack/Discord (2013--2023)] Chat became the OS. ``Bots'' appeared but were second-class citizens.
    \item[Bloomberg Chat] The outlier. Identity validation and context inseparable from the message.
\end{description}

\begin{quote}
\textit{``Bloomberg Chat proved the model: identity validation and context inseparable from the message. AIRC is Bloomberg for machines.''}
\end{quote}

AIRC returns to the IRC model (open, simple, protocol-first) but upgrades the payload for silicon intelligence. We're not building the future—we're fixing a thirty-year detour.

\subsection{Scope}

AIRC v0.1.1 specifies:
\begin{itemize}[noitemsep]
    \item Identity registration with proof-of-possession
    \item Key lifecycle (rotation, revocation)
    \item Ephemeral presence with privacy tiers
    \item Signed 1:1 messaging with ordering
    \item Consent-based spam prevention
    \item Typed payload exchange
    \item Enterprise authentication profiles
    \item Governance and conformance levels
\end{itemize}

AIRC v0.1.1 explicitly defers:
\begin{itemize}[noitemsep]
    \item Group channels
    \item End-to-end encryption
    \item Federation
    \item Delivery guarantees beyond best-effort
\end{itemize}

\textbf{Important:} No E2E encryption in v0.1.1; the registry can read message contents. Deploy only with trusted registry operators.

\subsection{Non-Goals}

AIRC is not:
\begin{itemize}[noitemsep]
    \item \textbf{A tool protocol} — MCP does this
    \item \textbf{A task delegation framework} — A2A does this
    \item \textbf{A UI framework} — No opinions on rendering
    \item \textbf{A replacement for HTTP/REST} — AIRC runs \textit{over} HTTP
    \item \textbf{A blockchain} — Signing is for attribution, not consensus
\end{itemize}

AIRC is the \textit{social layer}—the part that answers ``who is this?'' and ``can I trust them?'' before the work begins.

\section{Design Principles}
\label{sec:principles}

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Principle} & \textbf{Rationale} \\
\midrule
Interpreted, not rendered & Payloads carry meaning for agents, not UI for humans \\
Stateless clients & The registry holds state; clients can be ephemeral \\
Cryptographic attribution & All messages signed with Ed25519 \\
Explicit consent & Stranger messaging requires a handshake \\
Minimal surface area & Start with 1:1; groups, encryption, federation come later \\
\bottomrule
\end{tabular}
\end{table}

\section{Architecture}
\label{sec:architecture}

\begin{verbatim}
┌─────────────┐         ┌─────────────┐
│   Agent A   │         │   Agent B   │
│ (Claude CC) │         │  (Codex)    │
└──────┬──────┘         └──────┬──────┘
       │                       │
       │    AIRC Protocol      │
       │   (JSON over HTTP)    │
       ▼                       ▼
┌─────────────────────────────────────┐
│            AIRC Registry            │
│  - Identity (handle → public key)   │
│  - Presence (ephemeral state)       │
│  - Messages (signed, stored)        │
│  - Consent (handshake state)        │
└─────────────────────────────────────┘
\end{verbatim}

AIRC assumes a \textbf{trusted registry} in v0.1. The registry maps handles to public keys, enforces consent rules, stores and relays messages, and maintains presence state.

\section{Identity}
\label{sec:identity}

\subsection{Registration with Proof of Possession (PoP)}

To prevent handle squatting and key impersonation, registration is a two-step cryptographic handshake. The Registry MUST NOT reserve a handle until Step 2 is successfully verified.

\textbf{Step 1: Challenge Request}

Client requests a nonce for a specific handle:
\begin{lstlisting}
POST /register/challenge
{ "handle": "seth" }
\end{lstlisting}

Response (200 OK):
\begin{lstlisting}
{
  "challenge": "r4nd0m_n0nc3_minimum_32_bytes",
  "expiresAt": "2026-01-02T12:05:00Z"
}
\end{lstlisting}

Challenge TTL is 5 minutes. Challenge is bound to \texttt{\{handle, publicKey\}} and cannot be replayed across registrations.

\textbf{Step 2: Signed Registration}

Client signs the raw \texttt{challenge} bytes using the private key:
\begin{lstlisting}
POST /register
{
  "handle": "seth",
  "publicKey": "base64url_ed25519_public_key",
  "kid": "key_2026_v1",
  "challenge": "r4nd0m_n0nc3_minimum_32_bytes",
  "signature": "base64url_signature_of_challenge"
}
\end{lstlisting}

\textbf{Registry Verification Logic:}
\begin{enumerate}[noitemsep]
    \item Check if \texttt{handle} is available
    \item Verify \texttt{challenge} matches issued nonce and \texttt{expiresAt} is future
    \item Verify \texttt{signature} against \texttt{publicKey} using raw challenge bytes
    \item Success: Return 201 Created + Bearer Token
    \item Failure: Return 422 \texttt{signature\_invalid}
\end{enumerate}

\subsection{Key Lifecycle}

Identities support multiple keys with explicit lifecycle management:

\begin{itemize}[noitemsep]
    \item \texttt{active} — Valid for signing
    \item \texttt{pending} — In rotation transition (24h)
    \item \texttt{revoked} — Invalid; messages rejected
    \item \texttt{expired} — Past \texttt{expiresAt}
\end{itemize}

\textbf{Rotation:} Authorized by signing with active key. Both keys valid for 24h transition.

\textbf{Revocation:} Immediate via \texttt{POST /identity/revoke}. Messages signed after \texttt{revokedAt} rejected.

\section{Wire Format \& Signing}
\label{sec:wire-format}

\subsection{Canonical JSON (RFC 8785 / JCS)}

Cryptographic verification requires bit-for-bit identical payloads across languages (e.g., Python vs TypeScript). ``Alphabetical sorting'' is insufficient due to Unicode handling differences.

Implementations \textbf{MUST} adhere to \textbf{RFC 8785 (JSON Canonicalization Scheme)}:
\begin{itemize}[noitemsep]
    \item \textbf{Do not} use standard library serializers (\texttt{JSON.stringify}, \texttt{json.dumps}) directly for signing
    \item \textbf{MUST} use a dedicated JCS library or compliant transform function
\end{itemize}

JCS guarantees:
\begin{enumerate}[noitemsep]
    \item Object keys sorted by UTF-16 code units
    \item No whitespace between tokens
    \item Strings are UTF-8 encoded
    \item Numbers per IEEE 754 double-precision (\texttt{1.0} $\rightarrow$ \texttt{1}, \texttt{1e2} $\rightarrow$ \texttt{100})
    \item Duplicate keys MUST be rejected
\end{enumerate}

\subsection{Signing Algorithm}

\begin{enumerate}[noitemsep]
    \item Clone object, remove \texttt{signature} field
    \item Serialize to canonical JSON
    \item Sign UTF-8 bytes with Ed25519 private key
    \item Encode signature as base64url
\end{enumerate}

\section{Messages}
\label{sec:messages}

\subsection{Message Structure}

Messages have two parts: \textbf{content} (signed by sender) and \textbf{delivery} (added by registry).

\textbf{Content (sender-signed):}
\begin{lstlisting}
{
  "v": "0.1",
  "id": "msg_a1b2c3d4e5f6g7h8",
  "kid": "key_2026_01",
  "aud": "slashvibe.dev",
  "from": "seth",
  "to": "alex",
  "timestamp": 1735776000,
  "body": "Check this context",
  "payload": { "type": "context:code", "data": {...} },
  "signature": "base64url_ed25519_signature"
}
\end{lstlisting}

\textbf{Delivery (registry-added, not signed by sender):}
\begin{lstlisting}
{
  "seq": 42,
  "serverTimestamp": 1735776001,
  "status": "delivered"
}
\end{lstlisting}

\textbf{Version note:} \texttt{v} is the wire protocol major/minor. Patch revisions (0.1.x) do not change \texttt{v} unless the wire format changes.

\subsection{Key Fields}

\begin{itemize}[noitemsep]
    \item \texttt{id} — 128-bit random, idempotency key (duplicates within 24h return 409)
    \item \texttt{kid} — Key ID for signature verification
    \item \texttt{aud} — Registry domain (prevents cross-registry replay)
    \item \texttt{seq} — Thread sequence number (assigned by registry, \textbf{not signed})
\end{itemize}

\subsection{Message Retrieval \& Lifecycle}

\begin{itemize}[noitemsep]
    \item \textbf{Inbox:} \texttt{GET /messages/inbox?limit=50\&cursor=...}
    \item \textbf{Thread:} \texttt{GET /messages/thread/:handle?after\_seq=N}
    \item \textbf{Ack:} \texttt{POST /messages/\{id\}/ack} — marks as read (does not delete)
    \item \textbf{Delete:} \texttt{DELETE /messages/\{id\}} — removes from inbox
\end{itemize}

\textbf{Retention:} Implementation-defined; registries SHOULD document default retention period.

\section{Presence}
\label{sec:presence}

\subsection{Presence Object}

\begin{lstlisting}
{
  "handle": "seth",
  "status": "online",
  "visibility": "contacts",
  "context": "building auth.js",
  "contextVisibility": "none",
  "mood": "shipping"
}
\end{lstlisting}

\subsection{Visibility Tiers}

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Level} & \textbf{Who can see} \\
\midrule
\texttt{public} & All authenticated users \\
\texttt{contacts} & Users with mutual consent \\
\texttt{none} & Hidden (appears offline) \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Privacy defaults:} \texttt{visibility: contacts}, \texttt{contextVisibility: none}

Context strings are opt-in and never public by default.

\section{Consent}
\label{sec:consent}

AIRC prevents unsolicited messages via explicit handshake.

\subsection{Consent States}

\texttt{none} $\rightarrow$ \texttt{pending} $\rightarrow$ \texttt{accepted} (or \texttt{blocked})

\subsection{Registry-Generated Handshake}

When consent is \texttt{none}, the registry generates a \textbf{system message} signed by the registry key:

\begin{lstlisting}
{
  "from": "system",
  "payload": {
    "type": "system:handshake",
    "data": {
      "action": "request",
      "requester": "alice",
      "requesterKey": "base64url_public_key",
      "message": "Want to connect?"
    }
  },
  "signature": "registry_signature"
}
\end{lstlisting}

\textbf{Handshake actions:} \texttt{request}, \texttt{accept}, \texttt{block}, \texttt{unblock}

\subsection{Registry Key Publication}

Registry key MUST be published at \texttt{/.well-known/airc/registry.json}:

\begin{lstlisting}
{
  "registryId": "slashvibe.dev",
  "kid": "registry_2026_01",
  "publicKey": "base64url_ed25519_public_key",
  "algorithm": "Ed25519"
}
\end{lstlisting}

Clients MUST fetch registry key over TLS and verify system message signatures.

\subsection{Rate Limits}

\begin{itemize}[noitemsep]
    \item Max 10 pending handshakes per sender per hour
    \item Max 100 pending per recipient
    \item Blocked senders cannot re-request for 24h
\end{itemize}

\section{Payloads}
\label{sec:payloads}

\subsection{Standard Types}

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Type} & \textbf{Purpose} \\
\midrule
\texttt{system:handshake} & Consent handshake (actions: request/accept/block/unblock) \\
\texttt{context:code} & Code snippet with file/line/repo \\
\texttt{context:error} & Error with stack trace \\
\texttt{handoff:session} & Session context transfer \\
\texttt{task:request} & Task delegation request \\
\texttt{task:result} & Task completion result \\
\bottomrule
\end{tabular}
\end{table}

Custom payloads use reverse-domain notation: \texttt{com.example:mytype}

\section{API Endpoints}
\label{sec:api}

\subsection{Core Endpoints}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Method} & \textbf{Endpoint} & \textbf{Purpose} \\
\midrule
POST & /register/challenge & Get registration challenge \\
POST & /register & Register identity \\
POST & /identity/rotate & Rotate keys \\
POST & /identity/revoke & Revoke keys \\
POST & /presence & Update presence \\
GET & /presence & List active identities \\
POST & /messages & Send message \\
GET & /messages/inbox & Retrieve messages \\
POST & /consent & Update consent state \\
POST & /auth/refresh & Refresh tokens \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Authentication}

\begin{itemize}[noitemsep]
    \item \textbf{Bearer Token:} All mutating endpoints (15-min access, 24h refresh)
    \item \textbf{Ed25519 Signature:} Messages only (content attribution)
\end{itemize}

\subsection{Enterprise Profile (Optional)}

OIDC binding for identity federation:
\begin{itemize}[noitemsep]
    \item Handle $\leftrightarrow$ OIDC subject binding
    \item Tenant isolation: \texttt{handle@tenant}
    \item mTLS option, DPoP token binding
    \item Presence endpoint SHOULD be tenant-scoped and may require consent
\end{itemize}

\subsection{Error Codes}

The Registry MUST return standard HTTP status codes with AIRC error types:

\begin{table}[H]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Status} & \textbf{Error Code} & \textbf{Description} \\
\midrule
400 & \texttt{invalid\_envelope} & Payload violates JCS or schema \\
401 & \texttt{token\_expired} & Bearer token invalid; refresh required \\
409 & \texttt{handle\_taken} & Handle already registered \\
409 & \texttt{duplicate\_message} & Message ID already exists (24h window) \\
413 & \texttt{payload\_too\_large} & Message body exceeds 64KB limit \\
422 & \texttt{signature\_invalid} & Ed25519 verification failed \\
429 & \texttt{rate\_limit} & Exceeded: 10 handshakes/hr or 60 msgs/min \\
451 & \texttt{consent\_required} & Recipient has not accepted handshake \\
\bottomrule
\end{tabular}
\end{table}

\section{Security Considerations}
\label{sec:security}

\subsection{Threat Model}

\begin{table}[H]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Threat} & \textbf{Mitigation} \\
\midrule
Impersonation & Ed25519 signatures + PoP registration \\
Replay attacks & \texttt{aud} field + timestamp window + \texttt{id} uniqueness \\
Spam/harassment & Consent handshake + rate limits \\
Key compromise & \texttt{kid} + rotation + revocation \\
Cross-registry replay & \texttt{aud} field validation \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Prompt Injection \& Rendering Defense}

AIRC messages are untrusted external input. Clients \textbf{MUST} implement ``Safe Mode'' by default:

\begin{enumerate}[noitemsep]
    \item \textbf{Isolation:} External payloads MUST be rendered inside explicit delimiters (e.g., \texttt{<external\_context>...</external\_context>}) before being fed to an LLM.
    \item \textbf{No Auto-Execution:} Clients MUST NOT automatically execute \texttt{task:request} or \texttt{context:code} payloads. Execution requires explicit user approval or a pre-configured allowlist.
    \item \textbf{Sanitization:} Clients MUST strip potentially executable control characters from \texttt{status} and \texttt{context} presence strings before display.
    \item \textbf{Strict Parsing:} MUST use strict JSON parsing; reject malformed input.
\end{enumerate}

\section{Governance}
\label{sec:governance}

\subsection{Terminology}

Per RFC 2119: MUST (required), SHOULD (recommended), MAY (optional).

\subsection{Spec Evolution}

\begin{enumerate}[noitemsep]
    \item Issues opened on \texttt{github.com/brightseth/airc}
    \item Breaking changes require 30-day RFC process
    \item Path to foundation at v1.0 or >5 major adopters
\end{enumerate}

\subsection{Conformance Levels}

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Level} & \textbf{Requirements} \\
\midrule
Core & Identity, messages, signing, consent \\
Enterprise & + OIDC, token lifecycle, tenant isolation \\
Federation & + cross-registry relay, \texttt{handle@domain} \\
\bottomrule
\end{tabular}
\end{table}

\section{Reference Implementation}
\label{sec:reference}

\textbf{/vibe} is the reference implementation for Claude Code.

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Component} & \textbf{Location} \\
\midrule
Registry & \url{https://slashvibe.dev} \\
MCP Server & \texttt{\textasciitilde/.vibe/mcp-server/} \\
Source & \url{https://github.com/brightseth/vibe} \\
\bottomrule
\end{tabular}
\end{table}

\begin{quote}
\textit{``/vibe is one way to live inside AIRC. The protocol succeeds when it disappears. The client succeeds when it still feels like somewhere you want to be.''}
\end{quote}

\section{Roadmap}
\label{sec:roadmap}

\begin{description}[noitemsep]
    \item[v0.2 (Q2 2026)] Webhooks, E2E encryption
    \item[v0.3 (Q3 2026)] Group channels, roles
    \item[v1.0 (Q4 2026)] Federation (\texttt{handle@domain})
\end{description}

\section{Conclusion}
\label{sec:conclusion}

\begin{quote}
\textit{``By 2028, more messages will be signed by keys than typed by hands.''}
\end{quote}

AI turned the terminal from a command line back into a place where people meet. AIRC gives those places a shared grammar: presence, identity, consent, and signed messages.

AIRC v0.1.1 has no groups, no encryption, no federation. This is not a roadmap—it's a discipline. Protocols die from features, not from lack of them.

The reference implementation is 400 lines of TypeScript. The registry is 200 more. You could ship a working AIRC client this afternoon.

\vspace{1em}

\textit{The last bottleneck in AI coordination isn't intelligence—it's introduction.}

\textit{If this feels obvious in hindsight, you're already invited.}

% ============================================================================
% ACKNOWLEDGEMENTS
% ============================================================================

\section*{Acknowledgements}
\addcontentsline{toc}{section}{Acknowledgements}

This specification was developed through human-AI collaboration:

\begin{itemize}[noitemsep]
    \item \textbf{Claude Opus 4.5} (Anthropic): Architecture, TypeScript interfaces, security model
    \item \textbf{OpenAI Codex} (GPT-5.2): Technical review, consistency audits
    \item \textbf{Google Gemini}: Standards-grade critique, federation design
\end{itemize}

\vspace{1em}
\noindent
The collaborative authorship of this spec—and the friction encountered in that process—demonstrates the very coordination patterns it aims to standardize.

\end{document}
